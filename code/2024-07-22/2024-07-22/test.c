//#define _CRT_SECURE_NO_WARNINGS
//
////#include<stdio.h>
////int main()
////{
////	char a = -1;
////	signed char b = -1;
////	unsigned char c = -1;
////
////	// - 1在内存中的 原码 为10000000000000000000000000000001
////	// - 1在内存中的 反码 为11111111111111111111111111111110
////	// - 1在内存中的 补码 为11111111111111111111111111111111
////	// 在存入到char中时。从低位截断8个。11111111
////	// 在打印时，整形提升 为11111111111111111111111111111111
////	// 因为为有符号数，所以有符号的概念，高位第一位代表符号。在提升时其余位补符号
////	// 还原为 原码   后为 为10000000000000000000000000000001
////	// 所以打印为-1
////	// 在存入到unsigned char中时。从低位截断8个byte 11111111
////	// 因为为无符号，所以没有符号位的概念。在这里也代表数值
////	// 所以整形提升后补0  为00000000000000000000000011111111
////	// 所以打印为 255
////	printf("a=%d,b=%d,c=%d", a, b, c);
////	return 0;
////}
////// char -128~127
//
//
//
//
////#include <stdio.h>
////
////int main()
////{
////	char a = -128; 
////	//-128   10000000000000000000000010000000 - 原码
////	//-128   11111111111111111111111101111111 - 反码
////	//-128   11111111111111111111111110000000 - 补码
////	// 存储在cahr中为10000000
////	// 打印为无符号时。整形提升。因为char为有符号的类型，
////	//       11111111111111111111111110000000 - 补码
////	//       11111111111111111111111110000000 - 原码
////	printf("%u\n"，a);  // 4,294,967,168
////	//%u -打印无符号整数/1
////	return 0;
////}
//////在进行整形提升的时候， 要根据数据的类型来判断补0 还是补  1
//
////#include<stdio.h>
////int main()
////{
////	char a = 128;
////	//128 - 00000000000000000000000010000000 - 原码
////	//128 - 11111111111111111111111101111111 - 反码
////	//128 - 11111111111111111111111110000000 - 补码
////	// 截断  10000000
////	//提升  11111111111111111111111110000000 - 补码
////	//打印  11111111111111111111111110000000 - 原码
////	printf("%u\n", a);
////	return 0;
////}
//////结果一样。
//
////#include <stdio.h>
////int main()
////{
////	int i = -20;
////	unsigned int j = 10;
////	//-20    10000000000000000000000000010100 -源码
////	//-20    11111111111111111111111111101011 -反码
////	//-20    11111111111111111111111111101100 -补码
////	// 10    00000000000000000000000000001010 -补码
////	//-20+10 11111111111111111111111111110110 -补码
////	//int 和unsigned int提升为 后者.但是他是按照%d的形式输出需要转换为原码
////	// 符号位不变，取反+1
////	//       10000000000000000000000000001001 - 反码
////	//       10000000000000000000000000001010 - 原码      
////	// 所以打印出来为 - 10
////	printf("%d\n",i + j);
////	return 0;
////}
//
////#include <stdio.h>
////
////int main()
////{
////	unsigned int i = 0; 
////	for (i = 9; i >= 0; i--)
////		printf("%u\n",i);
////	//打印9 8 7 6 5 4 3 2 1 0
////	//到-1时，对于%u的整形  -1的补码是32个1.他是一个很大的正数
////	return 0;
////}
//
////#include<stdio.h>
////#include<string.h>
////int main()
////{
////	char a[1000];
////	int i = 0;
////	for (i = 0; i < 1000; i++)
////	{
////		a[i] = -1 - i;
////	}
////	printf("%d",strlen(a));  
////	// strlen求字符串长度。 到\0结束 。他的ascii为0
////	// char a 的范围为-128 ~ 127
////	// a[i]的值会从-1开始  -2 -3 -4 -5 ...-128  此时再-1 就会变成
////	//-128 补码	   10000000
////	//-128 -1 补码 01111111
////	// 反码        01111111
////	// 原码        01111111   = 127
////	//    .... -128  127  126 ......3 2 1 0 到 \0结束，
////	// 之前一共有128 + 127 = 255个数字
////	// 所以字符串长度为255
////	return 0;
////}
//
////#include<stdio.h>
////int main()
////{
////	unsigned char i = 0;
////
////	for (i = 0; i <= 255; i++)
////	{
////		printf("hello world\n");
////	}
////	return 0;
////	//这里的 char为 unsigned修饰。
////	//在从0到127最大值后 变为11111111 对于无符号。他的值为正数
////	//再继续加会被截断为00000000  然后继续循环
////	//unsigned char的取值范围为0-255
////}
//
////#include<stdio.h>
////#include <string.h>
////
////int main()
////{
////	if (strlen("abc") - strlen("abcdef") >= 0)
////		printf(">\n"); 
////	else
////		printf("<\n");
////	return 0;
////	//strlen的返回值是size_t类型。也就是unsigned int 类型
////	//他们相减后的也是一个无符号整数。也是正数。
////}
//
////
////#include <stdio.h>
////int main()
////
////{
////	int i = 0;
////	int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; 
////	for (i = 0; i <= 12; i++)
////	{
////		arr[i] = 0;
////		printf("hello bit\n");
////	}
////return 0;
////}
//////问这段代码为什么会死循环
//////答   在debug的内存存储中。变量i是在 数组arr后的第。在对arr[10]开始后的 11 12 都属于非法访问
////// 但是他们在内存中确实是被赋值为 00 00 00 00 了。因为i也在其中，所以i就又变成0了，使得i<=12 为真。 
////// 循环继续。周而复始
//
//
//////输入一个整数数组，实现一个函数,
//////来调整该数组中数字的顺序
////// 使得数组中所有的奇数位于数组的前半部分
////// 所有偶数位于数组的后半部分。
////
////#include<stdio.h>
////
////void move_odd_even(int arr[], int sz)
////{
////	int left = 0;
////	int right = sz - 1;
////	while (left<right)
////	{
////		//从左向右找偶数，停下来
////		while ((left < right) && (arr[left] % 2 == 1))//这里要注意不要让left越界
////		{
////			left++;
////		}
////		//从右向左找奇数数，停下来
////		while ((left < right) && (arr[right] % 2 == 0))
////		{
////			right--;
////		}
////		//交换奇数和偶数
////		if (left < right)
////		{
////			int temp = arr[left];
////			arr[left] = arr[right];
////			arr[right] = temp;
////			left++;//交换这俩数字之后，再往中间聚拢
////			right--;
////		}
////	}
////}
////
////int main()
////{
////	int arr[10] = { 0 };
////	//输入
////	int sz = sizeof(arr) / sizeof(arr[0]);
////	int i = 0;
////	for (i = 0; i < sz; i++)
////	{
////		scanf("%d", &arr[i]);
////	}
////	// 1 2 3 4 5 6 7 8 9 10
////	// 1 3 5 7 9 2 4 6 8 10
////	//调整
////	move_odd_even(arr, sz);
////	//输出
////	for (i = 0; i < sz; i++)
////	{
////		printf("%d ", arr[i]);
////	}
////	return 0;
////}
//
////有序数列的合并
////将两个数组的值 输出为一行。按照升序
////思路 用两个指针来对比大小，谁小输出谁
//#include <stdio.h>	
//int main()
//{
//	int arr1[5] = { 0 };
//	int sz1 = sizeof(arr1) / sizeof(arr1[0]);
//	int arr2[6] = { 0 };
//	int sz2 = sizeof(arr2) / sizeof(arr2[0]);
//	int i = 0;
//	for ( i = 0; i < sz1; i++)
//	{
//		scanf("%d", &arr1[i]);
//	}
//	for (i = 0; i < sz2; i++)
//	{	
//		scanf("%d", &arr2[i]);
//	}
//	int j = 0;
//	int k = 0;
//	while (j < sz1 && k < sz2) //j和k不能越界
//	{
//		if (arr1[j] < arr2[k])
//		{
//			printf("%d ",arr1[j]);//arr1小就输出arr1
//			j++;
//		}
//		else//arr2小就输出arr2
//		{
//			printf("%d ", arr2[k]);
//			k++;
//		}
//	}
//	//循环完之后，可能会有数组没打印完。因为j或者k跳出去了
//	if (j < 10)//说明arr1没打印完，要从j开始打印
//	{
//		for (; j < sz1; j++)
//		{
//			printf("%d ", arr1[j]);
//		}
//	}
//	else//否则说明arr2没打印完，要从K开始打印
//	{
//		for (; k < sz2; k++)
//		{
//			printf("%d ", arr2[k]);
//		}
//	}
//
//	return 0;
//}

//const char* p = "hello";
//printf("%s", p);
//```
//
//这里注意，hello并不是存到了指针变量p中。而是p保存了首字母h的地址。
//
//这里使用const是为了保护字符串。
//如果const不用其实也改不了。 不过编译器会报错

//
////一道笔试题
//int main()
//{
//	const char* p1 = "abcdef"; 
//	const char* p2 = "abcdef";
//	char arr1[] = "abcdef"; 
//	char arr2[] = "abcdef";
//	if (p1 == p2)
//		printf("p1 == p2\n");
//	else
//		printf("p1!=p2\n");
//
//	if (arr1 == arr2)
//		printf("arr1 == arr2\n");
//	else
//		printf("arr1 != arr2\n");
//	return 0;
//	//输出结果是p1 = p2  arr1 != arr2
//	//说明。p1 和p2 都指向了内存中的只读区域中的 a。地址相同 
//	//但是arr1 和arr 2 是单独开辟了一片内存。有不同的地址
//}

//#include <stdio.h>
//int main()
//{
//	int arr1[5] = { 1, 2, 3, 4, 5};
//	int arr2[5] = { 3, 4, 5, 6, 7};
//	int arr3[5] = { 4, 5, 6 ,8, 9};
//
//	int* arr[3] = { arr1, arr2, arr3 };
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", arr[i][j]);
//			//arr[0]指的是指针数组arr下标为0的元素。即arr1
//			//arr1[j] = arr1 数组中下标为j个元素
//		}
//		printf("\n");
//	}
//
//
//	return ;
//}


//利用数组指针来输出一个二维数组的内容
#include <stdio.h>

void my_printf(int(*arr)[5], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			//printf("%d ",arr[i][j]);
				// 这里的arr虽然是第一行的地址但也是二维数组的地址，
				// 因为不管是二维数组还是一位数组，
				// 他们的首地址都是第一行第一个的元素的地址
			//printf("%d ",*(*(arr+i)+j));
				// 这里的*(arr+i)  arr指的是第一行的地址，+1则是第二行的地址
			printf("%d ",(*(arr+i))[j]);
				// 这里的*(arr+i) 指的是第第i行的地址 括号不能去掉，不然会有问题
				// [j]前面的解引用之后就等同于某行的数组名首地址。
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
	my_printf(arr, 3, 5);//这里的arr传入的是二维数组的第一个元素。
		                 //即二维数组的第一行。
	return	0;
}
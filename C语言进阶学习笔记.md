# 进阶学习 C 语言可以编写的程序以及个人的理解记录

介绍

这些是我在学习C语言的过程中自己练习的一些题目以及个人笔记

大家也可以参考着来学习

正在更新，初阶学习在→[初阶部分](https://blog.csdn.net/L_Z_J_I/article/details/140400417?spm=1001.2014.3001.5501)←可以点击打开

**大家可以在[我的gitee仓库](https://gitee.com/Xiao____liu/learning---c-language) 中下载笔记源文件**

**笔记源文件可以在Notion中导入**

# 一、深度剖析数据在内存中的存储

**本章重点**

1. 数据类型详细介绍
2. 整形在内存中的存储:原码、反码、补码
3. 大小端字节序介绍及判断
4. 浮点型在内存中的存储解析

## 1. 数据类型的介绍

- char            1字节
- short          2字节
- int               4字节
- long           在64位中占8字节 在32位系统重占4字节
- long long     C99中引入     8字节
- float             4字节
- double         8字节

**类型的意义:**

1. 使用这个类型开辟内存空间的大小(大小决定了使用范围)
2. 类型决定如何看待内存空间的视角

### 1.1 类型的基本归类

> **整形家族**
> 
- char
    - unsigned char
    - signed char
- short
    - unsigned short [int]
    - signed short [int]
- int
    - unsigned int
    - signed int
- long
    - unsigned long [int]
    - signed long [int]
- long long double
- 他们在头文件limits.h的头文件中

其中cahr  字符的本质是ASCII值，是整形
unsigned 为无符号
signed     为有符号    默认为有符号的。

在使用unsigned时，32为byte都可以用来做数值位置。
原来的符号位不用了。符号位为1=2^31

> **浮点型家族**
> 
- float
- double
- long double
- 他们在float.h的头文件中

其中float精度低。存储数值范围小
double精度高。存储的数值范围更大

> **构造类型**
> 
- 数组类型
- 结构体类型 struct
- 枚举类型    enum
- 联合类型    union

> **指针类型**
> 
- int* pi
- cahr* pi
- float* pi
- **void* pi**

等等都是指针类型

> 空类型
> 

void 表示空类型(无类型)
通常应用于函数的返回类型、函数的参数、指针类型。

1. 函数的在定义式用void。表示函数不会返回值
2. 函数的参数为void。表示函数不需要 传参，你别给我传！（强行传会警告）

## 2.整形在内存中的存储

### 2.1原码、反码、补码

计算机中的整数有三种2进制表示方法，即原码、反码和补码。
三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正“，用1表示“负”，而数值位正数的原、反、补码都相同。
负整数的三种表示方法各不相同。
**原码**
直接将数值按照正负数的形式翻译成二进制就可以得到原码。
**反码**
将原码的符号位不变，其他位依次按位取反就可以得到反码。
**补码**
反码+1就得到补码。

为什么要用补码来存储呢?
在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理;
同时，**加法和减法**也可以统一处理(CPU只有加法器)（-1和1补码相加=0000..0000）
此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
**（补码也可以取反+1得到原码。他们的计算过程是相同的）**

### 2.2大小端介绍

我们可以看到整形存储在内存中的补码。但是我们发现内存上顺序有点不对劲。是从右往左的
这是又为什么?

> **什么大端小端:**
大端(存储)模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中;
小端(存储)模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。
> 

左边为低地址，右边为高地址 。
字节序是以字节为单位进行排序。
比如a= 0x 11 22 33 44   
但是存储在内存中的是11 22 33 44    就叫做大端字节序存储   （在码中左边的为高位）
**VS中存储的为小端的存储模式、 他会倒着存进去**

**大端【字节序】存储:**
把一个数据的**高位字节序**的内容存放在**低地址处**，把低位字节序的内容放在高地址处，就是大端字节序存储。
**小端【字节序】存储:**
把一个数据的高位字节序的内容存放在高地址处，把低位字节序的内容放在低地址处，就是小端字节序存储。

### 为什么有大小端？

为什么会有大小端模式之分呢?因为在许算机系统举，我是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8 bit。但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型(要看具体的编译器)，另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。
例如:一个16bit的 short型x，在内存中的地址为0x0010，x的值为 0x1122，那么 0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即 0x0011中。小端模式，刚好相反。我们常用的x86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

**和硬件有关。**

### 写一个判断大小端的程序

这里考察对申请内存和指针操作权限的理解

```c
int main()
{
int a = 1;
if(*(char*)&a == 1) //把int型的a的地址，转化为char型。让他只能读取第一个字节的内容。
	printf("小端\n");   //如果为01 00 00 00 则为倒装。把高位放到高地址。 是小端 、
	else                    //否则为大端。
	printf(“大端\n");
return 0;
}
```

### 整形存储 练习

> 一、数据截断、整型提升规则
> 

```c
#include<stdio.h>
int main()
{
	char a = -1; 
	signed char b = -1;
	unsigned char c = -1;

	// - 1在内存中的 原码 为10000000000000000000000000000001
	// - 1在内存中的 反码 为11111111111111111111111111111110
	// - 1在内存中的 补码 为11111111111111111111111111111111
	// 在存入到char中时。从低位截断8个。11111111
	// 在打印时，整形提升 为11111111111111111111111111111111
	// 因为为有符号数，所以有符号的概念，高位第一位代表符号。在提升时其余位补符号
	// 还原为 原码   后为 为10000000000000000000000000000001
	// 所以打印为-1
	// 在存入到unsigned char中时。从低位截断8个byte 11111111
	// 因为为无符号，所以没有符号位的概念。在这里也代表数值
	// 所以整形提升后补0  为00000000000000000000000011111111
	// 所以打印为 255
	printf("a=%d,b=%d,c=%d", a, b, c);
	return 0;
}
	// char -128~127
```

**`char`**：通常是一个 8 位的有符号整数，范围是 `-128` 到 `127` 。

**`unsigned char`**：8 位的无符号整数，范围是 `0` 到 `255` 。

**`short`**：通常是 16 位的有符号整数，范围是 `-32768` 到 `32767` 。

**`unsigned short`**：16 位的无符号整数，范围是 `0` 到 `65535` 。

**`int`**：在大多数系统中是 32 位的有符号整数，范围是 `-2147483648` 到 `2147483647` 。

**`unsigned int`**：32 位的无符号整数，范围是 `0` 到 `4294967295` 。

**`long`**：在 32 位系统中通常与 `int` 范围相同；在 64 位系统中，通常是 64 位的有符号整数，范围更大。

**`unsigned long`**：对应的无符号类型。

**`long long`**：64 位的有符号整数，范围是 `-9223372036854775808` 到 `9223372036854775807` 。

**`unsigned long long`**：64 位的无符号整数，范围是 `0` 到 `18446744073709551615` 。

> 二、在进行整形提升的时候， 要根据数据的类型来判断补0 还是补  1
> 

```c
#include <stdio.h>

int main()
{
	char a = -128; 
	//-128   10000000000000000000000010000000 - 原码
	//-128   11111111111111111111111101111111 - 反码
	//-128   11111111111111111111111110000000 - 补码
	// 存储在cahr中为10000000
	// 打印为无符号时。整形提升。因为char为有符号的类型，
	//       11111111111111111111111110000000 - 补码
	//       11111111111111111111111110000000 - 原码
	printf("%u\n"，a);  // 4,294,967,168
	//%u -打印无符号整数/1
	return 0;
}
//在进行整形提升的时候， 要根据数据的类型来判断补0 还是补  1
```

> 三、结果一样。
> 

```c
#include<stdio.h>
int main()
{
	char a = 128;
	//128 - 00000000000000000000000010000000 - 原码
	//128 - 11111111111111111111111101111111 - 反码
	//128 - 11111111111111111111111110000000 - 补码
	// 截断  10000000
	//提升  11111111111111111111111110000000 - 补码
	//打印  11111111111111111111111110000000 - 原码
	printf("%u\n", a);
	return 0;
}
//结果一样。
```

> 四、注意类型转换。强制提升并不会影响最后以% 啥的形式打印
> 

```c
#include <stdio.h>
int main()
{
	int i = -20;
	unsigned int j = 10;
	//-20    10000000000000000000000000010100 -源码
	//-20    11111111111111111111111111101011 -反码
	//-20    11111111111111111111111111101100 -补码
	// 10    00000000000000000000000000001010 -补码
	//-20+10 11111111111111111111111111110110 -补码
	//int 和unsigned int提升为 后者.但是他是按照%d的形式输出需要转换为原码
	// 符号位不变，取反+1
	//       10000000000000000000000000001001 - 反码
	//       10000000000000000000000000001010 - 原码      
	// 所以打印出来为 - 10
	printf("%d\n",i + j);
	return 0;
}
```

> 五、-1在无符号打印为很大的正数
> 

```c
#include <stdio.h>

int main()
{
	unsigned int i = 0; 
	for (i = 9; i >= 0; i--)
		printf("%u\n",i);
	//打印9 8 7 6 5 4 3 2 1 0
	//到-1时，对于%u的整形  -1的补码是32个1.他是一个很大的正数
	return 0;
}
```

> 六、字符串求长度 和char 赋值
> 

```c
#include<stdio.h>
#include<string.h>
int main()
{
	char a[1000];
	int i = 0;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	printf("%d",strlen(a));  
	// strlen求字符串长度。 到\0结束 。他的ascii为0
	// char a 的范围为-128 ~ 127
	// a[i]的值会从-1开始  -2 -3 -4 -5 ...-128  此时再-1 就会变成
	//-128 补码	   10000000
	//-128 -1 补码 01111111
	// 反码        01111111
	// 原码        01111111   = 127
	//    .... -128  127  126 ......3 2 1 0 到 \0结束，
	// 之前一共有128 + 127 = 255个数字
	// 所以字符串长度为255
	return 0;
}
```

> 七、unsigned char的取值范围为0-255
> 

```c

#include<stdio.h>
int main()
{
	unsigned char i = 0;

	for (i = 0; i <= 255; i++)
	{
		printf("hello world\n");
	}
	return 0;
	//这里的 char为 unsigned修饰。
	//在从0到127最大值后 变为11111111 对于无符号。他的值为正数
	//再继续加会被截断为00000000  然后继续循环
	//unsigned char的取值范围为0-255
}
```

> 八、库函数strlen 返回值为无符号数
> 

```c

#include<stdio.h>
#include <string.h>

int main()
{
	if (strlen("abc") - strlen("abcdef") >= 0)
		printf(">\n"); 
	else
		printf("<\n");
	return 0;
	//strlen的返回值是size_t类型。也就是unsigned int 类型
	//他们相减后的也是一个无符号整数。也是正数。
}
```

## 3.浮点型在内存中的存储

常见的浮点数

> 3.14
1E10    1.0*10^10
> 

### 3.1浮点数存储的一个例子

**整形和浮点型在存储和获取值时他们的方法是不一样的**

```c
#include <stdio.h>
int main()
{
	int n = 9; 
	float* pFloat = (float*)&n;
	printf("n的值为:%d\n",n);  // 9
	printf("*pFloat的值为:%f\n", * pFloat); //以浮点数的形式来打印整数

	*pFloat = 9.0; 
	printf("num的值为:%d\n",n ); //以整数的方式来打印浮点数
	printf("*pFloat的值为:%f\n", * pFloat);//以浮点数的方式来打印浮点数
	//所以他们打印出来的值与我们预想的不一样。  
	
	return 0;
}
```

### 3.2 浮点数存储规则

根据国际标准IEEE(电气和电子工程协会)754，任意一个二进制浮点数V可以表示成下面的形式

- V = -（1）^2  ×*M*×2^E
- (-1)^S表示符号位，所以当S=0，V为正数;  当S=1，V为负数。
- M表示有效数字，大于等于1，小于2。
- 2^E表示指数位。

**比如V = 5.0 f**

在二进制中表示的形式是101.0  
                              他等价于1.01 * 2^2   
                           =  （-1）^0 × 1.01 × 2^2

                     V    = （-1）^S × M     ×2^E

                           所以**S = 0    M=1.1    E=2** 

**再举例子  V = 9.5f**      那么他的二进制是1001.1 （小数点后的1 位 2的 -1 次方）

=（-1）^0  × 1.0011 × 2^3

所以S = 0   M=1.0011   E=3

我们也由此可以了解浮点数的精度问题

例如V = 1.6  那么他的二进制数为1.1XXX  后面的XX是因为后面的2的n次方。但是float只能存四位字节。即使是double也才能存8个字节。
没办法精确的等于0.1  这个值。所以精度会丢失

**IEEE 754规定：**
对于32位的浮点数，
最高的1位是符号位S，紧接着的**8位**是指数E，剩下的**23位**为有效数字M

对于64位的浮点数，

最高的1位是符号位S，紧接着的**11位**是指数E，剩下的**23位**为有效数字M   

**补零补后边**

**IEEE 754对有效数字M和指数E，还有一些特别规定。**

1. 对于数字M
    
    前面说过，1≤M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分
    
    IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，**只保存01**，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位
    将第一位的1舍去以后，等于可以保存24位有效数字。 这样存储数据的精度就会更高
    
2. 对于数字E，情况就比较复杂（E有可能是负数）
    
    首先，E为一个无符号整数(unsignedint)这意味着，如果E为8位I它的取值范围为0~255;如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，
    
    所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127;**对于11位的E，这个中间数是1023。**
    
    真实值（E）+中间值 ( 172 / 1023 )
    
    比如，2^10的**E是10**，所以保存成32位浮点数时，必须保存成**10+127**=137，即10001001.
    

**然后，指数E从内存中取出还可以再分成三种情况:**

1. E不全为0或不全为1
    
    > 这时，浮点数就采用下面的规则表示，即指数E的计算值**减去127(**或1023)，**得到真实值，**再将有效数字M前加上第一位的**1。**
    比如:
    0.5(1/2)的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为1.0*2^(-1)，其阶码为-1+127=126，表示为
    01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000，则其二进制表示形式为:`0 01111110 00000000000000000000000`
    > 
2. E全为0
    
    > **这时，浮点数的指数E等于1-127(或者1-1023)**即为真实值有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示+0，以及接近于0的很小的数字。
    > 
3. E为全1
    
    > 这时，如果有效数字M全为0，表示+无穷大(正负取决于符号位s)
    > 

# 二、指针的进阶

**本章重点**

1. 字符指针
2. 数组指针
3.  指针数组
4.  数组传参和指针传参
5. 函数指针
6. 函数指针数组
7. 指向函数指针数组的指针
8.  回调函数
9. 指针和数组面试题的解析

指针的主题，我们在初级阶段的《指针》章节已经接触过了，我们知道了指针的概念
1.擂针就是个变量，**用来存放地址**，地址唯一标识一块内存空间。
2.指针的大小是固定的**4/8**个字节(32位平台/64位平台)。
3.指针是有类型，**指针的类型决定了指针的+-整数的步长**，指针解引用操作的时候的权限。
4.指针的运算。

## 字符指针

在指针的类型中有一个char*

正常使用不说了

他也可以这样使用

```c
const char* p = "hello";
printf("%s",p);
```

这里注意，hello并不是存到了指针变量p中。而是p保存了首字母h的地址。

这里使用const是为了保护字符串。 
如果const不用其实也改不了。 不过编译器会报错

一道面试题

```c
//一道笔试题
int main()
{
	const char* p1 = "abcdef"; 
	const char* p2 = "abcdef";
	char arr1[] = "abcdef"; 
	char arr2[] = "abcdef";
	if (p1 == p2)
		printf("p1 == p2\n");
	else
		printf("p1!=p2\n");

	if (arr1 == arr2)
		printf("arr1 == arr2\n");
	else
		printf("arr1 != arr2\n");
	return 0;
	//输出结果是p1 = p2  arr1 != arr2
	//说明。p1 和p2 都指向了内存中的只读区域中的 a。地址相同 
	//但是arr1 和arr 2 是单独开辟了一片内存。有不同的地址
}
```

## 指针数组

是用来存放指针的数组

指针数组来关联三个数组的代码示例

```c
#include <stdio.h>
int main()
{
	int arr1[5] = { 1, 2, 3, 4, 5};
	int arr2[5] = { 3, 4, 5, 6, 7};
	int arr3[5] = { 4, 5, 6 ,8, 9};

	int* arr[3] = { arr1, arr2, arr3 };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 5; j++)
		{
			printf("%d ", arr[i][j]);
			//arr[0]指的是指针数组arr下标为0的元素。即arr1
			//arr1[j] = arr1 数组中下标为j个元素
		}
		printf("\n");
	}
	return ;
}
```

## 数组指针

> **数组指针是指针。举例**
> 

```c
int *p1[10];  //p1 为指针数组， 数组里面有是个指针 int*类型的  有[10]个元素
int(*p2)[10]; //p2 为数组指针，  指针指向的是一个有十个元素数组
```

 p1 为指针数组， 数组里面有是个指针 int*类型的  有[10]个元素

 p2 为数组指针，  指针指向的是一个有十个元素数组

> 数组指针是存放数组的地址，使用方法是
**`int(*p2)[10] = &arr`  他的类型是int* (*) [10]**
> 

> **再次讨论数组名**
> 

int arr [10] = { 0 };

数组名`arr`通常表示的都是**数组首元素的地址**

除了两个例外

1. 在`sizeof()`内  他计算的是整个数组的大小。  
2. 使用`&arr`     他取出的是整个数组的地址。 （如果你对他+1 则会跳过整个数组

### 利用数组指针来输出一个二维数组的内容

```c
#include <stdio.h>

void my_printf(int(*arr)[5], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			//printf("%d ",arr[i][j]);
				// 这里的arr虽然是第一行的地址但也是二维数组的地址，
				// 因为不管是二维数组还是一位数组，
				// 他们的首地址都是第一行第一个的元素的地址
			//printf("%d ",*(*(arr+i)+j));
				// 这里的*(arr+i)  arr指的是第一行的地址，+1则是第二行的地址
			printf("%d ",(*(arr+i))[j]);
				// 这里的*(arr+i) 指的是第第i行的地址 括号不能去掉，不然会有问题
				// [j]前面的解引用之后就等同于某行的数组名首地址。
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
	my_printf(arr, 3, 5);//这里的arr传入的是二维数组的第一个元素。
		                 //即二维数组的第一行。
	return	0;
}
```

学习了这些知识。理解一下下面的代码

```c
int arr[5];  //整形数组
int *parrl[10];  //指针数组。可以存放十个地址的数组
int(*parr2)[10]; //数组指针，可以存放数组地址的指针
int(*parr3[10])[5]; //数组指针数组 。可以存放数组地址数组
```

## 数组参数、指针参数

在写代码的时候难免要把【数组】或者【指针】传给函数，那函数的参数该如何设计呢?

**4.1 一维数组传参!**

```c
#include <stdio.h>
void test(int arr[])
void test(int arr[10])
void test(int *arr)
void test2(int *arr[20]) 
void test2(int **arr) 
int main()
int arr[10]= {0};
int *arr2[20]= {0};
test(arr);
test2(arr2);
```

以上都可以。在数组传参的时候。可以以数组【】接收。也可以用指针来接收

**4.2 二维数组传参！**

```c
void test(int arr[3][5])
{}
void test(int arr[][5])
{}
{}
void test(int(*arr)[5])
{}
int main()
{
	int arr[3][5]= {0};
	test(arr);
}
//注意不要用指针和指针数组以及二级指针来传二维数组的地址。
```

**4.3 一级指针传参**

传指针。用指针接收

形参部分是 整形指针的时候  可以传整形变量的地址、整形指针、整形数组名、
只要传过去的本质是一个整形指针

**4.4二级指针传参**

传二级指针。用二级指针接收

形参部分是 整形的二级指针的时候。 
可以传二级指针变量的地址 。也可以取一级指针变量的地址传过去、
指针数组也可以传过去。它相当于指针数组的首地址。

函数指针

## 函数指针

函数指针的本质是 指向函数的指针

函数的名字就是他的地址。和数组一样

用指针这样指向函数。和数组指针类似。

```c
void Add (int x, int y)
{
	return x + y;
}
int main()
{
	int (*pf)(int , int) = Add; // =&Add
	int ret = pf(2,3);  // =*pf(2, 3) 其实这个解引用没啥用，因为Add = &Add = pf
	printf("%d",ret);   //5
	return 0;
}

```
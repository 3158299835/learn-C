# 进阶学习 C 语言可以编写的程序以及个人的理解记录

介绍

这些是我在学习C语言的过程中自己练习的一些题目以及个人笔记

大家也可以参考着来学习

正在更新

**大家可以在[我的gitee仓库](https://gitee.com/Xiao____liu/learning---c-language) 中下载笔记源文件**

**笔记源文件可以在Notion中导入**

# 一、深度剖析数据在内存中的存储

**本章重点**

1. 数据类型详细介绍
2. 整形在内存中的存储:原码、反码、补码
3. 大小端字节序介绍及判断
4. 浮点型在内存中的存储解析

## 1. 数据类型的介绍

- char            1字节
- short          2字节
- int               4字节
- long           在64位中占8字节 在32位系统重占4字节
- long long     C99中引入     8字节
- float             4字节
- double         8字节

**类型的意义:**

1. 使用这个类型开辟内存空间的大小(大小决定了使用范围)
2. 类型决定如何看待内存空间的视角

### 1.1 类型的基本归类

> **整形家族**
> 
- char
    - unsigned char
    - signed char
- short
    - unsigned short [int]
    - signed short [int]
- int
    - unsigned int
    - signed int
- 1ong
    - unsigned long [int]
    - signed long [int]

其中cahr  字符的本质是ASCII值，是整形
unsigned 为无符号
signed     为有符号    默认为有符号的。

在使用unsigned时，32为byte都可以用来做数值位置。
原来的符号位不用了。符号位为1=2^31

> **浮点型家族**
> 
- float
- double

其中float精度低。存储数值范围小
double精度高。存储的数值范围更大

> **构造类型**
> 
- 数组类型
- 结构体类型 struct
- 枚举类型    enum
- 联合类型    union

> **指针类型**
> 
- int* pi
- cahr* pi
- float* pi
- **void* pi**

等等都是指针类型

> 空类型
> 

void 表示空类型(无类型)
通常应用于函数的返回类型、函数的参数、指针类型。

1. 函数的在定义式用void。表示函数不会返回值
2. 函数的参数为void。表示函数不需要 传参，你别给我传！（强行传会警告）

## 2.整形在内存中的存储

### 2.1原码、反码、补码

计算机中的整数有三种2进制表示方法，即原码、反码和补码。
三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正“，用1表示“负”，而数值位正数的原、反、补码都相同。
负整数的三种表示方法各不相同。
**原码**
直接将数值按照正负数的形式翻译成二进制就可以得到原码。
**反码**
将原码的符号位不变，其他位依次按位取反就可以得到反码。
**补码**
反码+1就得到补码。

为什么要用补码来存储呢?
在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理;
同时，**加法和减法**也可以统一处理(CPU只有加法器)（-1和1补码相加=0000..0000）
此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
**（补码也可以取反+1得到原码。他们的计算过程是相同的）**

### 2.2大小端介绍

我们可以看到整形存储在内存中的补码。但是我们发现内存上顺序有点不对劲。是从右往左的
这是又为什么?

> **什么大端小端:**
大端(存储)模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中;
小端(存储)模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。
> 

左边为低地址，右边为高地址 。
字节序是以字节为单位进行排序。
比如a= 0x 11 22 33 44   
但是存储在内存中的是11 22 33 44    就叫做大端字节序存储   （在码中左边的为高位）
**VS中存储的为小端的存储模式、 他会倒着存进去**

**大端【字节序】存储:**
把一个数据的**高位字节序**的内容存放在**低地址处**，把低位字节序的内容放在高地址处，就是大端字节序存储。
**小端【字节序】存储:**
把一个数据的高位字节序的内容存放在高地址处，把低位字节序的内容放在低地址处，就是小端字节序存储。

### 为什么有大小端？

为什么会有大小端模式之分呢?因为在许算机系统举，我是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8 bit。但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型(要看具体的编译器)，另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。
例如:一个16bit的 short型x，在内存中的地址为0x0010，x的值为 0x1122，那么 0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即 0x0011中。小端模式，刚好相反。我们常用的x86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

**和硬件有关。**

### 写一个判断大小端的程序

这里考察对申请内存和指针操作权限的理解

```c
int main()
{
int a = 1;
if(*(char*)&a == 1) //把int型的a的地址，转化为char型。让他只能读取第一个字节的内容。
	printf("小端\n");   //如果为01 00 00 00 则为倒装。把高位放到高地址。 是小端 、
	else                    //否则为大端。
	printf(“大端\n");
return 0;
}
```

## 3.浮点型在内存中的存储